"""Vulnerability scoring for settlements based on graph + OSINT signals."""

from __future__ import annotations

from typing import TYPE_CHECKING

from ..core.types import ControlStatus, VulnerabilityScore

if TYPE_CHECKING:
    from ..core.graph import DonbasGraph
    from ..core.metrics import GraphMetrics


class VulnerabilityAnalyzer:
    """Compute composite vulnerability scores for UA-held settlements."""

    def __init__(self, graph: "DonbasGraph", metrics: "GraphMetrics") -> None:
        self.dg = graph
        self.metrics = metrics

    def score_all(self) -> dict[str, VulnerabilityScore]:
        """Score all UA-held and contested settlements."""
        betweenness = self.metrics.betweenness_centrality()
        results: dict[str, VulnerabilityScore] = {}

        for sid, settlement in self.dg.settlements.items():
            control = self.dg.get_effective_control(sid)
            if control == ControlStatus.RU:
                continue

            ds = self.dg.dynamic_states.get(sid)

            vs = VulnerabilityScore(settlement_id=sid)

            # Connectivity: higher betweenness = more strategically important = more targeted
            vs.connectivity_score = min(betweenness.get(sid, 0.0) / 0.4, 1.0)

            # Supply disruption from dynamic state
            vs.supply_score = ds.supply_disruption if ds else 0.0

            # Force balance: use assault intensity as proxy for attacker pressure
            vs.force_balance_score = ds.assault_intensity if ds else 0.0

            # Terrain and fortification (inverted in compute())
            vs.terrain_score = settlement.terrain_difficulty
            vs.fortification_score = settlement.fortification_level

            # Assault intensity
            vs.assault_intensity_score = ds.assault_intensity if ds else 0.0

            # Frontline distance
            vs.frontline_score = ds.frontline_distance_km if ds else 50.0

            vs.compute()
            results[sid] = vs

        return results

    def top_vulnerable(self, top_n: int = 10) -> list[tuple[str, float]]:
        """Return top-N most vulnerable settlements."""
        scores = self.score_all()
        ranked = sorted(scores.items(), key=lambda x: x[1].composite, reverse=True)
        return [(sid, vs.composite) for sid, vs in ranked[:top_n]]
